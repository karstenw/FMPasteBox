<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="karstenw.20180225140915.1" a="E"><vh>Application</vh>
<v t="karstenw.20180207130038.1"><vh>@clean FMPasteBox.py</vh>
<v t="karstenw.20180207130303.1"><vh>Declarations</vh></v>
<v t="karstenw.20180212004119.1"><vh>Main loop</vh></v>
</v>
<v t="karstenw.20180207130137.1" a="E"><vh>@clean FMPasteBoxAppDelegate.py</vh>
<v t="karstenw.20180207130300.1"><vh>Declarations</vh></v>
<v t="karstenw.20180207130300.2"><vh>class FMPasteBoxAppDelegate</vh>
<v t="karstenw.20180207130300.3"><vh>initialize</vh></v>
<v t="karstenw.20180207225504.1"><vh>awakeFromNib</vh></v>
<v t="karstenw.20180207130300.6"><vh>applicationDidFinishLaunching_</vh></v>
<v t="karstenw.20180207130300.4"><vh>getClipboard_</vh>
<v t="karstenw.20180218113658.1"><vh>&lt;&lt;export clipboard to folder&gt;&gt;</vh></v>
</v>
<v t="karstenw.20180208030448.2"><vh>textView</vh></v>
<v t="karstenw.20180207130300.5"><vh>pushClipboard_</vh></v>
<v t="karstenw.20180207130300.7"><vh>showPreferencePanel_</vh></v>
</v>
</v>
<v t="karstenw.20180207130144.1"><vh>@clean FMPasteBoxPrefController.py</vh>
<v t="karstenw.20180207130257.1"><vh>Declarations</vh></v>
<v t="karstenw.20180207130257.2"><vh>class FMPasteBoxPreferenceController</vh>
<v t="karstenw.20180207130257.3"><vh>init</vh></v>
<v t="karstenw.20180207130257.4"><vh>windowWillClose_</vh></v>
<v t="karstenw.20180207130257.5"><vh>chooseFolder_</vh></v>
</v>
</v>
<v t="karstenw.20180207130148.1"><vh>@clean FMPasteBoxTools.py</vh>
<v t="karstenw.20180207130254.1"><vh>Declarations</vh></v>
<v t="karstenw.20180207131602.1"><vh>TOOLS</vh>
<v t="karstenw.20180207130254.2"><vh>num2ostype</vh></v>
<v t="karstenw.20180207130254.3"><vh>ostype2num</vh></v>
<v t="karstenw.20180207130254.4"><vh>makeunicode</vh></v>
<v t="karstenw.20180207130254.10"><vh>NSURL2str</vh></v>
<v t="karstenw.20180207130254.12"><vh>getFileProperties</vh></v>
<v t="karstenw.20180207130254.13"><vh>setFileProperties</vh></v>
<v t="karstenw.20180207130254.14"><vh>datestring_nsdate</vh></v>
<v t="karstenw.20180207130254.15"><vh>setFileModificationDate</vh></v>
<v t="karstenw.20180207130254.16"><vh>uniquepath</vh></v>
<v t="karstenw.20180207150126.1"><vh>gethashval</vh></v>
</v>
<v t="karstenw.20180207131612.1"><vh>DIALOGS</vh>
<v t="karstenw.20180207130254.5"><vh>cancelContinueAlert</vh></v>
<v t="karstenw.20180207130254.6"><vh>errorDialog</vh></v>
<v t="karstenw.20180207130254.7"><vh>getFileDialog</vh></v>
<v t="karstenw.20180207130254.8"><vh>getApplicationDialog</vh></v>
<v t="karstenw.20180207130254.9"><vh>getFolderDialog</vh></v>
<v t="karstenw.20180207130254.11"><vh>saveAsDialog</vh></v>
</v>
<v t="karstenw.20180207131708.1"><vh>PASTEBOARD TOOLS</vh>
<v t="karstenw.20180207130254.17"><vh>get_type_from_hexstring</vh></v>
<v t="karstenw.20180207130254.18"><vh>get_hexstring_for_type</vh></v>
<v t="karstenw.20180207130254.19"><vh>get_type_from_intstring</vh></v>
<v t="karstenw.20180207130254.20"><vh>get_flavor</vh></v>
<v t="karstenw.20180207130254.21"><vh>writePasteboardFlavour</vh></v>
<v t="karstenw.20180208030622.1"><vh>pasteboard types</vh></v>
<v t="karstenw.20180207135146.1"><vh>PasteboardType</vh></v>
<v t="karstenw.20180207193636.1"><vh>PasteboardEntry</vh></v>
<v t="karstenw.20180207191920.1"><vh>Pasteboard Type structures</vh>
<v t="karstenw.20180210171940.1"><vh>fmpPasteboardTypes</vh></v>
<v t="karstenw.20180210172000.1"><vh>displaynameTypes</vh></v>
<v t="karstenw.20180210172023.1"><vh>additionalFMPPasteboardTypes</vh></v>
</v>
<v t="karstenw.20180207130254.22"><vh>read_pb</vh></v>
</v>
</v>
<v t="karstenw.20180207130153.1" a="E"><vh>@clean FMPasteBoxVersion.py</vh>
<v t="karstenw.20180207130252.1"><vh>Declarations</vh></v>
</v>
<v t="karstenw.20180207130158.1"><vh>@clean fmpterms.py</vh>
<v t="karstenw.20180207130250.1"><vh>Declarations</vh></v>
</v>
<v t="karstenw.20180207130202.1"><vh>@clean setup.py</vh>
<v t="karstenw.20180207130247.1"><vh>Declarations</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="karstenw.20180207130038.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20180207130137.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20180207130144.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20180207130148.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20180207130153.1">@language python
@tabwidth -4
@others

</t>
<t tx="karstenw.20180207130158.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20180207130202.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20180207130247.1">"""
Script for building FMPasteBox

Usage:
    python setup.py py2app
"""
from distutils.core import setup
from setuptools.extension import Extension

import py2app

import FMPasteBoxVersion

setup(
    name = FMPasteBoxVersion.appname,
    version = FMPasteBoxVersion.version,
    description = FMPasteBoxVersion.description,
    long_description = FMPasteBoxVersion.longdescription,
    author = FMPasteBoxVersion.author,
    app=[{
        'script': "FMPasteBox.py",

        "plist": {
            "NSPrincipalClass": 'NSApplication',
            "CFBundleIdentifier": FMPasteBoxVersion.bundleID,
            "CFBundleName": FMPasteBoxVersion.appnameshort,
            "CFBundleSignature": FMPasteBoxVersion.creator,
            "CFBundleShortVersionString": FMPasteBoxVersion.version,
            "CFBundleGetInfoString": FMPasteBoxVersion.description,
            "NSHumanReadableCopyright": FMPasteBoxVersion.copyright,
        }
    }],

    data_files=[
        "English.lproj/MainMenu.nib",
        "English.lproj/Preferences.nib",
        #"English.lproj/FMPasteBoxDocument.nib",
        "+icon/FMPasteBox.icns",
        #"+icon/FMPasteBoxFile.icns",
        ],

    options={
        "py2app": {
            "iconfile": "+icon/FMPasteBox.icns",
            # "packages": [],
            "excludes": ["TkInter", 'Tcl', 'Tk'],
        }
    } )

</t>
<t tx="karstenw.20180207130250.1">version = 1.1
path = u'/Applications/FileMaker/FileMaker Pro 11 Advanced/FileMaker Pro Advanced.app'

classes = \
[('application', 'capp'),
 ('window', 'cwin'),
 ('document', 'docu'),
 ('database', 'cDB '),
 ('table', 'cTBL'),
 ('FileMaker_script', 'cSCP'),
 ('layout', 'ctbl'),
 ('field', 'ccol'),
 ('record', 'crow'),
 ('cell', 'ccel'),
 ('repetition', 'cREP'),
 ('request', 'cRQT'),
 ('menu_item', 'cmen'),
 ('menu', 'cmnu')]

enums = \
[('table', 'TABL'),
 ('view', 'VIEW'),
 ('read_only', 'nmod'),
 ('formulas_protected', 'fpro'),
 ('read_write', 'modf'),
 ('no_access', '\x00\x00\x00\x00'),
 ('read', '\x00\x00\x00\x01'),
 ('write', '\x00\x00\x00\x02'),
 ('update', '\x00\x00\x00\x04'),
 ('create', '\x00\x00\x00\x08'),
 ('delete', '\x00\x00\x00\x10'),
 ('read_write', '\x00\x00\x00\x03'),
 ('read_update', '\x00\x00\x00\x05'),
 ('read_create', '\x00\x00\x00\t'),
 ('read_delete', '\x00\x00\x00\x11'),
 ('write_update', '\x00\x00\x00\x06'),
 ('write_create', '\x00\x00\x00\n'),
 ('write_delete', '\x00\x00\x00\x12'),
 ('update_create', '\x00\x00\x00\x0c'),
 ('update_delete', '\x00\x00\x00\x14'),
 ('write_delete', '\x00\x00\x00\x18'),
 ('read_write_update', '\x00\x00\x00\x07'),
 ('read_write_create', '\x00\x00\x00\x0b'),
 ('read_write_delete', '\x00\x00\x00\x13'),
 ('write_update_create', '\x00\x00\x00\x0e'),
 ('write_update_delete', '\x00\x00\x00\x16'),
 ('update_create_delete', '\x00\x00\x00\x1c'),
 ('read_create_delete', '\x00\x00\x00\x19'),
 ('read_update_delete', '\x00\x00\x00\x15'),
 ('write_create_delete', '\x00\x00\x00\x1a'),
 ('read_update_create', '\x00\x00\x00\r'),
 ('no_delete', '\x00\x00\x00\x0f'),
 ('no_create', '\x00\x00\x00\x17'),
 ('no_update', '\x00\x00\x00\x1b'),
 ('no_read', '\x00\x00\x00\x1e'),
 ('no_write', '\x00\x00\x00\x1d'),
 ('full', '\x00\x00\x00\x1f'),
 ('ascending', '\x00\x00\x00\x00'),
 ('descending', '\x00\x00\x00\x01'),
 ('custom', '\x00\x00\x00\x04'),
 ('sum', 'TOTL'),
 ('count', 'CONT'),
 ('mean', 'MEAN'),
 ('standard_deviation', 'STDV'),
 ('average', 'AVRG'),
 ('minimum', 'MIN '),
 ('maximum', 'MAX '),
 ('unlocked', 'NOLK'),
 ('shared_lock', 'SHLK'),
 ('exclusive_lock', 'EXLK'),
 ('false', 'fals'),
 ('sharing_hidden', 'mltH'),
 ('true', 'true'),
 ('single', 'rSgl'),
 ('repeated', 'rFxd'),
 ('guest', 'pGST'),
 ('before_', 'befo'),
 ('after_', 'afte'),
 ('beginning_', 'bgng'),
 ('end_', 'end '),
 ('replace', 'rplc'),
 ('index', 'indx'),
 ('named', 'name'),
 ('ID_', 'ID  ')]

properties = \
[('best_type', 'pbst'),
 ('class_', 'pcls'),
 ('default_type', 'deft'),
 ('frontmost', 'pisf'),
 ('name', 'pnam'),
 ('version', 'vers'),
 ('bounds', 'pbnd'),
 ('visible', 'pvis'),
 ('index', 'pidx'),
 ('floating', 'isfl'),
 ('zoomable', 'iszm'),
 ('zoomed', 'pzum'),
 ('modal', 'pmod'),
 ('resizable', 'prsz'),
 ('has_close_box', 'hclb'),
 ('has_title_bar', 'ptit'),
 ('current_layout', 'pCLY'),
 ('current_record', 'pCRW'),
 ('current_table', 'pCTB'),
 ('current_cell', 'pCCL'),
 ('modified', 'imod'),
 ('multiuser', 'pMUr'),
 ('lock', 'pLCK'),
 ('access', 'pACS'),
 ('ID_', 'ID  '),
 ('protection', 'ppro'),
 ('kind', 'pKND'),
 ('choices', 'pCHS'),
 ('formula', 'pfor'),
 ('nulls_OK', 'pNLS'),
 ('repeats', 'pRPT'),
 ('repeat_size', 'pRPS'),
 ('unique_value', 'pUNQ'),
 ('globalValue', 'pGLL'),
 ('cellValue', 'vlue'),
 ('omitted', 'pOMT'),
 ('enabled', 'enbl'),
 ('item_number', 'itmn'),
 ('checked', 'pCHK')]

elements = \
[('applications', 'capp'),
 ('windows', 'cwin'),
 ('documents', 'docu'),
 ('databases', 'cDB '),
 ('tables', 'cTBL'),
 ('FileMaker_scripts', 'cSCP'),
 ('layouts', 'ctbl'),
 ('fields', 'ccol'),
 ('records', 'crow'),
 ('cells', 'ccel'),
 ('repetitions', 'cREP'),
 ('requests', 'cRQT'),
 ('menu_items', 'cmen'),
 ('menus', 'cmnu')]

commands = \
[('getURL', 'GURLGURL', [('for_accounts', 'pACT')]),
 ('exists', 'coredoex', []),
 ('show', 'miscmvis', []),
 ('close', 'coreclos', []),
 ('redo', 'miscredo', []),
 ('find', 'FMPRFIND', []),
 ('quit', 'aevtquit', []),
 ('cut', 'misccut ', []),
 ('get_remote_URL', 'FMPROPRM', []),
 ('open', 'aevtodoc', [('with_passwords', 'pPAS'), ('for_Accounts', 'pACT')]),
 ('create',
  'corecrel',
  [('new', 'kocl'),
   ('at', 'insh'),
   ('with_data', 'data'),
   ('with_properties', 'prdt')]),
 ('get_data', 'coregetd', [('as_', 'rtyp')]),
 ('event_info', 'coregtei', [('in_', 'wrcd')]),
 ('print_',
  'aevtpdoc',
  [('with_password', 'pPAS'),
   ('for_Accounts', 'pACT'),
   ('from_page', 'StPg'),
   ('to_page', 'NdPg'),
   ('with_copies', 'Cpis')]),
 ('duplicate', 'coreclon', [('to', 'insh')]),
 ('save', 'coresave', []),
 ('data_size', 'coredsiz', [('as_', 'rtyp')]),
 ('go_to', 'FMPRGOTO', []),
 ('sort', 'DATASORT', [('by', 'SRTE'), ('in_order', 'SRTT')]),
 ('undo', 'miscundo', []),
 ('set_data', 'coresetd', [('to', 'data')]),
 ('copy', 'misccopy', []),
 ('paste', 'miscpast', []),
 ('count', 'corecnte', [('class_', 'kocl')]),
 ('do_script', 'miscdosc', []),
 ('class_info', 'coreqobj', [('in_', 'wrcd')]),
 ('do_menu', 'miscmenu', [('menu_named', 'menn')]),
 ('delete', 'coredelo', [])]
</t>
<t tx="karstenw.20180207130252.1">import os

appname ="FMPasteBox"
appnameshort = "FMPasteBox"
author = "Karsten Wolf"

years = "2018"
copyright = 'Copyright %s %s' % (years, author)

version = "0.3.1"
creator = 'KWFP'
bundleID = "org.kw.FMPasteBox"

description = (u"Filemaker Pasteboard interface and editor")
longdescription = u"""FMPasteBox is a Mac OS X application for translating the FileMaker clipboard."""

#document_creator = "Created by %s %s" % (appname, version)

developmentversion = False
</t>
<t tx="karstenw.20180207130254.1"># -*- coding: utf-8 -*-

"""Some tools which are needed by most files.
"""

import sys
import os
import re
import struct
import traceback
import datetime
import unicodedata
import hashlib

import xml.etree.cElementTree
ElementTree = xml.etree.cElementTree

import mactypes
import appscript
asc = appscript

import pdb
import FMPasteBoxVersion
kwdbg = FMPasteBoxVersion.developmentversion
kwlog = FMPasteBoxVersion.developmentversion

import pprint
pp = pprint.pprint

import urllib
import urlparse

import objc

import Foundation
NSURL = Foundation.NSURL
NSFileManager = Foundation.NSFileManager
NSUserDefaults = Foundation.NSUserDefaults
NSString = Foundation.NSString

import AppKit
NSOpenPanel = AppKit.NSOpenPanel
NSAlert = AppKit.NSAlert
NSSavePanel = AppKit.NSSavePanel
NSFileHandlingPanelOKButton  = AppKit.NSFileHandlingPanelOKButton
NSPasteboard = AppKit.NSPasteboard
NSPasteboardCommunicationException = AppKit.NSPasteboardCommunicationException


</t>
<t tx="karstenw.20180207130254.10">def NSURL2str( nsurl ):
    if isinstance(nsurl, NSURL):
        return str(nsurl.absoluteString())
    return nsurl


</t>
<t tx="karstenw.20180207130254.11">def saveAsDialog(path):
    panel = NSSavePanel.savePanel()

    if path:
        panel.setDirectory_( path )

    panel.setMessage_( u"Save as OPML" )
    panel.setExtensionHidden_( False )
    panel.setCanSelectHiddenExtension_(True)
    panel.setRequiredFileType_( u"opml" )
    if path:
        if not os.path.isdir( path ):
            folder, fle = os.path.split(path)
        else:
            folder = path
            fle = "Untitled.opml"
        rval = panel.runModalForDirectory_file_(folder, fle)
    else:
        rval = panel.runModal()

    if rval == NSFileHandlingPanelOKButton:
        return panel.filename()
    return False


def datetimestamp( dt=None ):
    # '2018-02-17 19:41:02'
    if not dt:
        dt = datetime.datetime.now()
    now = str(dt)
    now = now[:19]
    d, t = now.split()
    t = t.replace(':', '')
    return (d,t)


</t>
<t tx="karstenw.20180207130254.12">def getFileProperties( theFile ):
    """
    """
    sfm = NSFileManager.defaultManager()
    props = sfm.fileAttributesAtPath_traverseLink_( theFile, True )
    if not props:
        return {}
    mtprops = props.mutableCopy()
    mtprops.removeObjectsForKeys_( [
        u"NSFileExtensionHidden",
        u"NSFileGroupOwnerAccountID",
        u"NSFileGroupOwnerAccountName",
        u"NSFileOwnerAccountID",
        u"NSFileOwnerAccountName",
        #u"NSFilePosixPermissions",
        #u"NSFileReferenceCount",
        # u"NSFileSize",
        #u"NSFileSystemFileNumber",
        u"NSFileSystemNumber",
        u"NSFileType",
        # u"NSFileHFSCreatorCode",
        # u"NSFileHFSTypeCode",
        #u"NSFileCreationDate"
        ] )
    return mtprops


</t>
<t tx="karstenw.20180207130254.13">def setFileProperties( theFile, props ):
    sfm = NSFileManager.defaultManager()
    return sfm.changeFileAttributes_atPath_( props, theFile )


</t>
<t tx="karstenw.20180207130254.14">def datestring_nsdate( dt=datetime.datetime.now() ):
    now = str(dt)
    now = now[:19]
    now = now + " +0000"
    return now


</t>
<t tx="karstenw.20180207130254.15">def setFileModificationDate( filepath, modfdt ):
    l = getFileProperties( filepath )
    date = Foundation.NSDate.dateWithString_( datestring_nsdate( modfdt ) )
    l['NSFileModificationDate'] = date
    setFileProperties( filepath, l)
    folder, filename = os.path.split( filepath )
    print "Setting file(%s) modification date to %s" % (filename, repr(modfdt))


</t>
<t tx="karstenw.20180207130254.16">def uniquepath(folder, filenamebase, ext, nfill=3, startindex=1, sep="_", always=True):
    """
    """
    folder = os.path.abspath( folder )
    
    if not always:
        path = os.path.join(folder, filename + ext )
        if not os.path.exists( path ):
            return path

    n = startindex
    while True:
        serialstring = str(n).rjust(nfill, "0")

        filename = filenamebase + sep + serialstring + ext

        fullpath = os.path.join(folder, filename)

        if n &gt;= 10**nfill:
            nfill = nfill + 1

        if not os.path.exists(fullpath):
            return fullpath

        n += 1


</t>
<t tx="karstenw.20180207130254.17">def get_type_from_hexstring( hexstring ):
    """Extract the 4-char macroman type code from the pasteboard type name."""
    h = int(hexstring, 16)
    s = struct.pack("&gt;I", h)
    s = unicode(s, 'macroman')
    return s


</t>
<t tx="karstenw.20180207130254.18">def get_hexstring_for_type( typ_ ):
    """
    """
    s = struct.pack( "BBBB", typ_ )
    i = struct.unpack( "&gt;I", s)
    return hex(i)


</t>
<t tx="karstenw.20180207130254.19">def get_type_from_intstring( intstring ):
    h = int(intstring)
    s = struct.pack("&gt;I", h)
    s = unicode(s, 'macroman')
    return s


</t>
<t tx="karstenw.20180207130254.2">def num2ostype( num ):
    if num == 0:
        return '????'
    s = struct.pack("&gt;I", num)
    return makeunicode(s, "macroman")


</t>
<t tx="karstenw.20180207130254.20">def get_flavor(s):
    """Return the 4-char type from a pasteboard name
    """
    
    # seems like the standart naming scheme for the pasteboard server
    re_pbtype = re.compile( u"CorePasteboardFlavorType 0x([A-F0-9]{,8})")

    m = re_pbtype.match(s)
    result = ""
    if m:
        t = m.groups()[0]
        result = get_type_from_hexstring(t)
    return result


</t>
<t tx="karstenw.20180207130254.21">def writePasteboardFlavour( folder, basename, ext, data ):
    p = uniquepath(folder, basename, ext)
    if data:
        f = open ( p, 'wb')
        f.write( data )
        f.close()


</t>
<t tx="karstenw.20180207130254.22">def read_pb():
    result = None
    hashes = set()

    additionals = []
    pasteboard = NSPasteboard.generalPasteboard()
    pbTypeNames = pasteboard.types()

    
    # additionalFMPPasteboardTypes

    for pbTypeName in pbTypeNames:

        pbType = mainType = None
        if pbTypeName in fmpPasteboardTypes:
            pbType = fmpPasteboardTypes.get( pbTypeName )
            mainType = True
        elif pbTypeName in additionalFMPPasteboardTypes:
            pbType = additionalFMPPasteboardTypes.get( pbTypeName )
            mainType = False

        if pbType == None:
            continue

        try:
            s = pasteboard.dataForType_( pbTypeName )
            data = s.bytes().tobytes()

            # dont load duplicate data
            hashval, _ = gethashval( data )
            if hashval in hashes:
                continue
            hashes.add( hashval )
            
            if mainType:
                data = makeunicode(data)

            pbTypeName = pbType.canonicalType
            
            pbEntry = PasteboardEntry(pbTypeName, data, pbType)
            
            if mainType:
                result = pbEntry
            else:
                additionals.append( pbEntry )

        except Exception, v:
            print v
            pdb.set_trace()
            pp(locals())
            print

    if result:
        result.additionals = additionals

    if kwlog:
        print
        print "result = "
        pp(result)
        print
    return result

</t>
<t tx="karstenw.20180207130254.3">def ostype2num( ostype ):
    return struct.pack('BBBB', list(ostype))


</t>
<t tx="karstenw.20180207130254.4">def makeunicode(s, srcencoding="utf-8", normalizer="NFC"):
    try:
        if type(s) not in (unicode, objc.pyobjc_unicode):
            s = unicode(s, srcencoding)
    except TypeError:
        print "makeunicode type conversion error"
        print "FAILED converting", type(s), "to unicode"
    s = unicodedata.normalize(normalizer, s)
    return s


</t>
<t tx="karstenw.20180207130254.5">def cancelContinueAlert(title, message, butt1="OK", butt2=False):
    """Run a generic Alert with buttons "Weiter" &amp; "Abbrechen".

       Returns True if "Weiter"; False otherwise
    """
    alert = NSAlert.alloc().init()
    alert.setAlertStyle_( 0 )
    alert.setInformativeText_( title )
    alert.setMessageText_( message )
    alert.setShowsHelp_( False )
    alert.addButtonWithTitle_( butt1 )

    if butt2:
        # button 2 has keyboard equivalent "Escape"
        button2 = alert.addButtonWithTitle_( butt2 )
        button2.setKeyEquivalent_( unichr(27) )

    f = alert.runModal()
    return f == AppKit.NSAlertFirstButtonReturn


</t>
<t tx="karstenw.20180207130254.6">def errorDialog( message="Error", title="Some error occured..."):
    return cancelContinueAlert(title, message)


</t>
<t tx="karstenw.20180207130254.7">def getFileDialog(multiple=False):
    panel = NSOpenPanel.openPanel()
    panel.setCanChooseFiles_(True)
    panel.setCanChooseDirectories_(False)
    panel.setAllowsMultipleSelection_(multiple)
    rval = panel.runModalForTypes_( None )
    if rval:
        return [t for t in panel.filenames()]
    return []


</t>
<t tx="karstenw.20180207130254.8">def getApplicationDialog():
    panel = NSOpenPanel.openPanel()
    panel.setCanChooseFiles_(True)
    panel.setCanChooseDirectories_(False)
    panel.setAllowsMultipleSelection_(False)
    rval = panel.runModalForTypes_( ['app'] )
    if rval:
        l = [makeunicode(t.path()) for t in panel.URLs()]
        return l[0]
    return ""


</t>
<t tx="karstenw.20180207130254.9">def getFolderDialog(multiple=False):
    panel = NSOpenPanel.openPanel()
    panel.setCanChooseFiles_(False)
    panel.setCanChooseDirectories_(True)
    panel.setAllowsMultipleSelection_(multiple)
    rval = panel.runModalForTypes_([])
    if rval:
        return [t for t in panel.filenames()]
    return []


</t>
<t tx="karstenw.20180207130257.1">#
#   FMPasteBoxPreferenceController.py
#
#   Created by Karsten Wolf on 07.02.18.
#   Copyright 2018 Karsten Wolf. All rights reserved.
#

import objc

import Foundation
NSUserDefaults = Foundation.NSUserDefaults


import AppKit
NSApplication = AppKit.NSApplication
NSWindowController = AppKit.NSWindowController

import FMPasteBoxTools



</t>
<t tx="karstenw.20180207130257.2">class FMPasteBoxPreferenceController (NSWindowController):

    butSetFileMakerAppPath = objc.IBOutlet()
    butSetExportsPath = objc.IBOutlet()

    cbDoExports = objc.IBOutlet()

    txtFileMakerAppPath = objc.IBOutlet()
    txtExportsPath = objc.IBOutlet()

    @others

</t>
<t tx="karstenw.20180207130257.3">def init(self):
    self = self.initWithWindowNibName_("Preferences")

    wnd = self.window()
    wnd.setTitle_( u"FMPasteBox Preferences" )
    wnd.setDelegate_( self )

    defaults = NSUserDefaults.standardUserDefaults()
    self.txtFileMakerAppPath.setStringValue_( defaults.objectForKey_( u'txtFileMakerAppPath') )
    self.txtExportsPath.setStringValue_( defaults.objectForKey_( u'txtExportsPath') )
    self.cbDoExports.setState_( defaults.objectForKey_( u'cbDoExports') )
    return self


</t>
<t tx="karstenw.20180207130257.4">def windowWillClose_(self, notification):
    defaults = NSUserDefaults.standardUserDefaults()
    defaults.setObject_forKey_(self.txtFileMakerAppPath.stringValue(),   u'txtFileMakerAppPath')
    defaults.setObject_forKey_(self.txtExportsPath.stringValue(),   u'txtExportsPath')
    defaults.setObject_forKey_(self.cbDoExports.state(),   u'cbDoExports')


</t>
<t tx="karstenw.20180207130257.5">@objc.IBAction
def chooseFolder_(self, sender):
    if sender == self.butSetFileMakerAppPath:
        folders = FMPasteBoxTools.getApplicationDialog()
        if folders:
            self.txtFileMakerAppPath.setStringValue_( folders )
    elif sender == self.butSetExportsPath:
        folders = FMPasteBoxTools.getFolderDialog()
        if folders:
            self.txtExportsPath.setStringValue_( folders[0] )


</t>
<t tx="karstenw.20180207130300.1">#
#  FMPasteBoxAppDelegate.py
#  FMPasteBox
#

import sys
import os

import pprint
pp = pprint.pprint

import pdb
kwlog = True

import objc

import Foundation
NSObject = Foundation.NSObject
NSMutableDictionary = Foundation.NSMutableDictionary
NSData = Foundation.NSData

import AppKit
NSWindowController = AppKit.NSWindowController
NSApplication = AppKit.NSApplication
NSUserDefaults = AppKit.NSUserDefaults
NSMutableAttributedString = AppKit.NSMutableAttributedString
NSBeep = AppKit.NSBeep
NSPasteboard = AppKit.NSPasteboard

import FMPasteBoxLayoutObjects

import FMPasteBoxTools
read_pb = FMPasteBoxTools.read_pb
makeunicode = FMPasteBoxTools.makeunicode
fmpPasteboardTypes = FMPasteBoxTools.fmpPasteboardTypes
additionalFMPPasteboardTypes = FMPasteBoxTools.additionalFMPPasteboardTypes
displaynameTypes = FMPasteBoxTools.displaynameTypes
datetimestamp = FMPasteBoxTools.datetimestamp


import FMPasteBoxVersion

import FMPasteBoxPrefController
PrefController = FMPasteBoxPrefController.FMPasteBoxPreferenceController

</t>
<t tx="karstenw.20180207130300.2">class FMPasteBoxAppDelegate(NSObject):

    menClipboardtype = objc.IBOutlet()
    butGetClipboard = objc.IBOutlet()
    butPushClipboard = objc.IBOutlet()
    tfXMLEditor = objc.IBOutlet()
    appWindow = objc.IBOutlet()

    @others
</t>
<t tx="karstenw.20180207130300.3">def initialize(self):
    if kwlog:
        print "FMPasteBoxAppDelegate.initialize()"
    userdefaults = NSMutableDictionary.dictionary()
    userdefaults.setObject_forKey_(u"", u'txtFileMakerAppPath')
    userdefaults.setObject_forKey_(u"", u'txtExportsPath')
    userdefaults.setObject_forKey_(False, u'cbDoExports')
    NSUserDefaults.standardUserDefaults().registerDefaults_(userdefaults)
    self.preferenceController = None


</t>
<t tx="karstenw.20180207130300.4">@objc.IBAction
def getClipboard_(self, sender):
    pasteboardContents = read_pb()
    if not pasteboardContents:
        # abort - nothing on pasteboard
        NSBeep()
        # we must return implicit None! Crashing otherwise.
        return
    defaults = NSUserDefaults.standardUserDefaults()
    exportClipboards = defaults.boolForKey_( u'cbDoExports' )
    if exportClipboards:
        exportFolder = makeunicode(defaults.objectForKey_( u'txtExportsPath' ))
        &lt;&lt;export clipboard to folder&gt;&gt;
    pbType = pasteboardContents.typ
    pbTypeName = pbType.name
    self.menClipboardtype.setTitle_( pbTypeName )
    self.tfXMLEditor.setString_( makeunicode( pasteboardContents.data ) )
    window = self.tfXMLEditor.window()
    window.makeFirstResponder_(self.tfXMLEditor)


</t>
<t tx="karstenw.20180207130300.5">@objc.IBAction
def pushClipboard_(self, sender):
    # get text view data
    data = makeunicode(self.textView())
    data = data.encode("utf-8")
    l = len(data)
    nsdata = NSData.dataWithBytes_length_(data, l)
    
    # get pasteboard type
    pasteboardType = displaynameTypes.get( self.menClipboardtype.title(), u"" )
    if not pasteboardType:
        NSBeep()
        # we must return implicit None! Crashing otherwise.
        return
    # write to pasteboard
    pasteboard = NSPasteboard.generalPasteboard()
    pasteboard.clearContents()
    pasteboardTypeName = pasteboardType.pbname
    pasteboard.setData_forType_( nsdata, pasteboardTypeName)


</t>
<t tx="karstenw.20180207130300.6">def applicationDidFinishLaunching_(self, notification):
    app = NSApplication.sharedApplication()
    app.activateIgnoringOtherApps_(True)
    window = self.tfXMLEditor.window()
    window.makeFirstResponder_(self.tfXMLEditor)


</t>
<t tx="karstenw.20180207130300.7">@objc.IBAction
def showPreferencePanel_(self, sender):
    if self.preferenceController == None:
        self.preferenceController = PrefController.alloc().init()
    self.preferenceController.showWindow_( self.preferenceController )

</t>
<t tx="karstenw.20180207130303.1">#
#  FMPasteBox.py
#  FMPasteBox
#

import objc
import Foundation
import AppKit

from PyObjCTools import AppHelper

import FMPasteBoxAppDelegate


</t>
<t tx="karstenw.20180207131602.1"></t>
<t tx="karstenw.20180207131612.1"></t>
<t tx="karstenw.20180207131708.1"></t>
<t tx="karstenw.20180207135146.1">class PasteboardType(object):
    canonicalTypes = {
        u'com.adobe.pdf': u'Apple PDF pasteboard type',
        u'public.jpeg': u"CorePasteboardFlavorType 0x4A504547",
        u'NeXT TIFF v4.0 pasteboard type': u'public.tiff',
        # XML2
        u'dyn.ah62d4rv4gk8zuxnqgk': u"CorePasteboardFlavorType 0x584D4C32",
        
    }

    def __init__(self, pbname, typ, dataType, name, fileExt):
        self.pbname = pbname
        self.typ = typ
        self.dataType = dataType
        self.name = name
        self.fileExt = fileExt
        self.canonicalType = self.canonicalTypes.get( pbname, pbname )


    def __repr__(self):
        return u"PasteboardType(%s, %s, %s, %s, %s, %s)" % (
                repr(self.pbname),
                repr(self.typ),
                repr(self.dataType),
                repr(self.name),
                repr(self.fileExt),
                repr(self.canonicalType),)


</t>
<t tx="karstenw.20180207150126.1">def gethashval( s ):
    m = hashlib.sha1()
    size = len(s)

    t = "blob %i\0%s" % (size, s)
    m.update(t)
    return  (m.hexdigest(), size)


</t>
<t tx="karstenw.20180207191920.1">

</t>
<t tx="karstenw.20180207193636.1">class PasteboardEntry(object):
    def __init__(self, name, data, typ):
        self.name = name
        self.data = data
        self.typ = typ
        self.additionals = []


    def __repr__(self):
        return u"PasteboardEntry(%s, data[%i], %s, %s)" % (
                repr(self.name),
                len(self.data),
                repr(self.typ),
                repr(self.additionals))
</t>
<t tx="karstenw.20180207225504.1">def awakeFromNib(self):
    # for later
    defaults = NSUserDefaults.standardUserDefaults()

    # set up type menu
    self.menClipboardtype.removeAllItems()
    menuItems = [ u"" ]
    menuItems.extend( displaynameTypes.keys() )
    menuItems.sort()
    for menuItem in menuItems:
        self.menClipboardtype.addItemWithTitle_( menuItem )
    self.menClipboardtype.setTitle_( u"" )
    # set up text view
    self.tfXMLEditor.setUsesFindPanel_(True)
    window = self.tfXMLEditor.window()
    window.makeFirstResponder_(self.tfXMLEditor)


</t>
<t tx="karstenw.20180208030448.2">def textView(self):
    # model
    return makeunicode( self.tfXMLEditor.string() )


</t>
<t tx="karstenw.20180208030622.1"># fmpa 15
# XML2 - 0x584D4C32 - generic xml for layout objects

# FMPA 11
# XMFN - 0x584D464E - Custom Functions

# FileMaker Advanced Pasteboard types    
# XMFD - 0x584D4644 - fields
# XMTB - 0x584D5442 - basetables
# XMSC - 0x584D5343 - scripts
# XMSS - 0x584D5353 - script step
# XMLO - 0x584D4C4F - layout objects


# FileMaker Developer Pasteboard types
# beides binaerformate
# FTR5 - 0x46545235 - 
# FMP5


</t>
<t tx="karstenw.20180210171940.1">fmpPasteboardTypes = {
    u"CorePasteboardFlavorType 0x584D4C32":
        PasteboardType(u"CorePasteboardFlavorType 0x584D4C32",
                        'XML2', 'fullXML', "Layout Objects", '.xml'),

    u"CorePasteboardFlavorType 0x584D5442":
        PasteboardType(u"CorePasteboardFlavorType 0x584D5442",
                        'XMTB', 'snippetXML', "Base Tables", '.xml'),


    u"CorePasteboardFlavorType 0x584D4644":
        PasteboardType(u"CorePasteboardFlavorType 0x584D4644",
                        'XMFD', 'snippetXML', "Fields", '.xml'),

    u"CorePasteboardFlavorType 0x584D5343":
        PasteboardType(u"CorePasteboardFlavorType 0x584D5343",
                        'XMSC', 'snippetXML', "Scripts", '.xml'),

    u"CorePasteboardFlavorType 0x584D5353":
        PasteboardType(u"CorePasteboardFlavorType 0x584D5353",
                        'XMSS', 'snippetXML', "Script Steps", '.xml'),

    u"CorePasteboardFlavorType 0x584D464E":
        PasteboardType(u"CorePasteboardFlavorType 0x584D464E",
                        'XMFN', 'snippetXML', "Custom Functions", '.xml'),

    u"CorePasteboardFlavorType 0x584D4C4F":
        PasteboardType(u"CorePasteboardFlavorType 0x584D4C4F",
                        'XMLO', 'snippetXML', "Layout Objects (obsolete)", '.xml'),
}


</t>
<t tx="karstenw.20180210172000.1">displaynameTypes = {}
# "Custom Functions" -&gt; PasteboardType(u"CorePasteboardFlavorType 0x584D464E",...
for typeName in fmpPasteboardTypes:
    typ = fmpPasteboardTypes[typeName]
    displaynameTypes[typ.name] = typ


</t>
<t tx="karstenw.20180210172023.1">additionalFMPPasteboardTypes = {
    u"CorePasteboardFlavorType 0x4A504547":
        PasteboardType(u"CorePasteboardFlavorType 0x4A504547",
                        'JPEG', 'binaryData',
                        "Layout Objects JPEG Image", '.jpg'),

    u'Apple PDF pasteboard type':
        PasteboardType(u'Apple PDF pasteboard type',
                        'PDF', 'binaryData',
                        "Layout Objects PDF Image", '.pdf'),

    u'com.adobe.pdf':
        PasteboardType(u'com.adobe.pdf',
                        'PDF', 'binaryData',
                        "Layout Objects PDF Image", '.pdf'),

    u'Apple PICT pasteboard type':
        PasteboardType(u'Apple PICT pasteboard type',
                        'PICT', 'binaryData',
                        "Layout Objects PICT Image (obsolete)", '.pict'),

    u'NeXT TIFF v4.0 pasteboard type':
        PasteboardType(u'NeXT TIFF v4.0 pasteboard type',
                        'TIFF', 'binaryData',
                        "Layout Objects TIFF Image", '.tif'),

    u'public.jpeg':
        PasteboardType(u'public.jpeg',
                        'JPEG', 'binaryData',
                        "Layout Objects JPEG Image", '.jpg'),

    u'public.tiff':
        PasteboardType(u'public.tiff',
                        'TIFF', 'binaryData',
                        "Layout Objects TIFF Image", '.tif'),
}


</t>
<t tx="karstenw.20180212004119.1">if __name__ == '__main__':
    AppHelper.runEventLoop()

</t>
<t tx="karstenw.20180218113658.1">if os.path.exists( exportFolder ):
    d,t = FMPasteBoxTools.datetimestamp()
    dayFolder = os.path.join( exportFolder, d )
    mainType = "-"
    try:
        mainType = mainType + pasteboardContents.typ.name
    except:
        pass
    sessionFolder = os.path.join( dayFolder, t + mainType)
    try:
        exportItems = pasteboardContents.additionals[:]
        exportItems.append( pasteboardContents )
        for item in exportItems:
            name = item.typ.name
            ext = item.typ.fileExt
            data = item.data
            path = os.path.join( sessionFolder, name + ext )
            if ext == ".xml":
                data = makeunicode( data )
                data = data.encode( "utf-8" )

            if not os.path.exists( sessionFolder ):
                os.makedirs( sessionFolder )
            f = open(path, 'w')
            f.write( data )
            f.close()

            if ext == ".xml":
                FMPasteBoxLayoutObjects.exportAssets( path, sessionFolder )
    except Exception, err:
        print
        print "ADDITIONALS FAILED"
        print err
        print
</t>
<t tx="karstenw.20180225140915.1"></t>
</tnodes>
</leo_file>
